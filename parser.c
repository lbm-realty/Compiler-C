#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "parser.h"
#include "front.h"

void variable();
void const_condition();

static void error();

void start()
{
    switch (nextToken)
    {
    case IDENT:
        lex();
        if (nextToken == ASSIGN_OP)
        {
            expr();
            if (nextToken == SEMICOLON)
                printf("Parsed Sucessfully\n");
            else
                error();
        }
    case KEY_IN:
        lex();
        if (nextToken == OPEN_PAREN)
        {
            variable();
            if (nextToken == SEMICOLON)
                printf("Parsed Sucessfully\n");
            else
                error();
        }
    case KEY_OUT:
        lex();
        if (nextToken == CLOSE_PAREN)
        {
            expr();
            if (nextToken == SEMICOLON)
                printf("Parsed Successfully\n");
            else
                error();
        }
    case KEY_IF:
        lex();
        if (nextToken == OPEN_PAREN) {
            const_condition();
            lex();
            if (nextToken == CLOSE_PAREN) {
                lex();
                if (nextToken == OPEN_CURL) {
                    start();
                    lex();
                    if (nextToken == CLOSE_CURL) {
                        lex();
                        if (nextToken == KEY_ELSE) {
                            lex();
                            if (nextToken == OPEN_CURL) {
                                lex();
                                start();
                                lex();
                                if (nextToken == CLOSE_CURL) {
                                    printf("Succesfully Parsed\n");
                                }
                                else error();
                            } else error();
                        } else {
                            // Checking is the nextTokenn after if () {} '}' this is blank or not
                            // Because the if condition can either end or have an else block, no other thing
                            char* next = tokenName(nextToken); 
                            if (isblank(next[0]) || isspace(next[0])) {
                                break;
                            }
                            else error();
                        }
                    } else error();
                } else error();
            } else error();
        } else error();
        // Another case is needed for S S, keep in mind
    }


}

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void expr()
{
    /* Parse the first term */
    lex();
    term();

    // switch(nextToken) {
    //     case IDENT:
    //         lex();
    //         if (nextToken == SUB_OP || nextToken == ADD_OP)
    //             expr();
    //         else if (nextToken == SEMICOLON) printf("Successfully parsed\n");
    //     case INT_LIT:
    //         lex();
    //         if (nextToken == SUB_OP || nextToken == ADD_OP || nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP)
    //             expr();
    //         else if (nextToken == SEMICOLON) printf("Successfully parsed\n");
    // }

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }

    printf("Exit <expr>\n");
} /* End of function expr */

void const_condition()
{
    lex();
    switch (nextToken)
    {
    case IDENT:
        expr();
        if (nextToken == LESSER_OP || nextToken == GREATER_OP || nextToken == EQUAL_OP || 
            nextToken == NEQUAL_OP || nextToken == LEQUAL_OP || nextToken == GEQUAL_OP )
        {
            expr();
            if (nextToken == SEMICOLON)
                printf("Parsed Successfully\n");
            else
                error();
        }
        else
            error();
    case OPEN_PAREN:
        const_condition();
        if (nextToken == CLOSE_PAREN)
        {
            lex();
            if (nextToken == SEMICOLON)
                printf("Parsed Successfully\n");
            else
                error();
        }
        else
        {
            error();
            return;
        }
    }
    while (nextToken == BOOL_AND || nextToken == BOOL_OR) {
        lex();
        expr();

        switch(nextToken) {
            case LESSER_OP:
            case GREATER_OP:
            case EQUAL_OP:
            case NEQUAL_OP:
            case LEQUAL_OP:
            case GEQUAL_OP:
                lex();
                expr();
                break;

        }
    }

}

void variable()
{
    lex();
    char *str = tokenName(nextToken);
    if (isalpha(str[0]))
    {
        lex();
        if (nextToken == CLOSE_PAREN)
            lex();
        else
        {
            error();
            return;
        }
    }
    else
        error();

    // Now we just have two steps left
    // We are at the alphabet now that's usually inside the parenthesis input (n), in this case n
    // Now we have to look if the syntax ends correctly, i.e., with a closed paren and semicolon
}

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term()
{
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        lex();
        factor();
    }
    printf("Exit <term>\n");
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor()
{
    if (nextToken == IDENT || nextToken == INT_LIT)
    {
        lex();
    }
    else
    {
        if (nextToken == OPEN_PAREN)
        {
            // lex();
            expr();
            if (nextToken == CLOSE_PAREN) lex();
            else error();
        }
        else error();
    }
}

static void error()
{
    printf("Error (more is desired, but not implemented).\n");
}
